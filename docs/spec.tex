\documentclass[10pt]{article}

% Lines beginning with the percent sign are comments
% This file has been commented to help you understand more about LaTeX

% DO NOT EDIT THE LINES BETWEEN THE TWO LONG HORIZONTAL LINES

%---------------------------------------------------------------------------------------------------------

% Packages add extra functionality.
\usepackage{times,graphicx,epstopdf,fancyhdr,amsfonts,amsthm,amsmath,algorithm,algorithmic,xspace,hyperref}
\usepackage[left=1in,top=1in,right=1in,bottom=1in]{geometry}
\usepackage{sect sty}	%For centering section headings
\usepackage{enumerate}	%Allows more labeling options for enumerate environments 
\usepackage{epsfig}
\usepackage[space]{grffile}
\usepackage{booktabs}
\usepackage{forest}

% This will set LaTeX to look for figures in the same directory as the .tex file
\graphicspath{.} % The dot means current directory.

\pagestyle{fancy}

\lhead{Final Project}
\rhead{\today}
\lfoot{CSCI 334: Principles of Programming Languages}
\cfoot{\thepage}
\rfoot{Fall 2023}

% Some commands for changing header and footer format
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\headwidth}{\textwidth}
\renewcommand{\footrulewidth}{0.4pt}

% These let you use common environments
\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{observation}{Observation}
\newtheorem{question}{Question}

\setlength{\parindent}{0cm}


%---------------------------------------------------------------------------------------------------------

% DON'T CHANGE ANYTHING ABOVE HERE

% Edit below as instructed

\begin{document}
  
\section*{Documentation: Blueprint}

Benjamin Wilen

\subsection{Overview of Minimal Working Version}

Given Blueprint's purpose of enabling users to create blueprints via a program, there are two main features that are essential to the functionality of the program.
1) Users should be able to define reusable types. For example, if an architect reuses a kitchen layout, they might want to save that as a custom type. 2) Users can use instances of built in types
and custom types to produce Blueprint objects. Although the 2nd feature is the more critical one for the output of this language, for the minimially working version I implemented the 1st feature Because
I think it is the building block of the language and should be used internally as well. For example, for the final project, I will have a standard libraries of objects such as couch, fireplace, sink, staircase, etc.
which internally can be implemented as custom types.
\\\\
To implement type definitions, I treat type declerations as non-scoped function declerations. A type definition has a name, optional formal parameters, and returns a Expr. As a result, I treat functions similar to how we store variables,
using an env map that holds the type name as the key, and the value is a TypeDef object which includes the parameters and the children objects. Lastly, I do not consider scope for function implementation because these are simple functions
in the sense that you can't do logic or computations within the function, only return children objects.
\\\\
For the final version of this project, the output will be SVG files for each level specified in a program. However, because the second feature isn't implemented in this version,
I currently print the env returned from evaluation to check that the type definitions were properly specified and stored in the environment.


\subsection{Minimum Formal Grammar in BNF}
\begin{verbatim}
<Blueprint> ::= <expr>+
<expr> ::= <typeDef> | <instance>
<typedef> ::= type <var>(<pars>)[<instances>]
<instances> ::= <instance>*
<instance> ::= <level> | <room> | <furniture>
<level> ::= Level(<attributes>) [<instances>]
<room> ::= Room(<attributes>) [<instances>]
<furniture> ::= Furniture(<attributes>)
<attributes> ::= <attribute>*
<attribute> ::= <key>=<value>,
<key> ::= <string>
<value> ::= <string> | <num> | <var> 
<var> ::= <char> | <var><char>
<pars> ::= <par>*
<par> ::= <var>,
<num> ::= <d><num> | <d>
<d> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<char> ::= {'a'...'z'}
\end{verbatim}

\subsection{Minimal Semantics}
% Table with three columns: Name, Age, Gender
\begin{tabular}{c|c|c|c|c}
    \hline
    \textbf{Syntax} & \textbf{Abstract Syntax} & \textbf{Type} & \textbf{Prec/Assoc} & \textbf{Meaning} \\
    \hline
    n & Number of int & int & n/a & n is a primitive \\
    "string" & EString of string & string & n/a & "string" is a primitive \\
    x & Variable of string & string & n/a & stored variable identifier \\
    "id"="ex" & Attribute of Expr * Expr & 'a -> 'b -> string & n/a & Attribute of an object such as location or size \\
    Furniture() & Furniture of Expr list & 'a list -> string & 2, N/A & a furniture object that returns the svg of the furniture item \\
    Room()[] & Room of Expr list * Expr list & 'a list -> 'b list -> string & 2, N/A & a room object that returns the svg of the room item \\
    Level()[] & Level of Expr list * Expr list & 'a list -> 'b list -> string & 2, N/A & a level object that returns the svg of the level item \\
    type test ()[] & Assignment of Expr * Expr & 'a -> 'b -> Expr & 1, N/A & a type definition for resuable object collections \\
    \hline
\end{tabular}

\subsection{Next Steps}
For next steps, there are obvious extensions and improvements that need to be made to this working version. First, as mentioned earlier, the implementation of actually created blueprint SVGs.
This will require a more complex evaluation function, however, I believe the current parsing function already includes this feature. The AST needs to be cleaned up a little bit to be less flexible with certain nested layers. For example, given the current AST, a program can be just a number, but a program should only be a Sequence of Assignments, Levels, Rooms, and Furniture.
Finally, the grammer parsing should be cleaned up and improved slightly for readability, most noticably allowing whitespace flexibility.

% DO NOT DELETE ANYTHING BELOW THIS LINE
\end{document}
